#!/usr/bin/env ruby

require 'fileutils'
require './util'

@fwd = File.expand_path(File.dirname(__FILE__))
@messages = File.join(@fwd, 'messages')

FileUtils.mkdir_p(@messages)

ENV['GIT_DIR'] = 'pidgin.git'

@commit_authors = File.open('commit_authors', 'w')
@svn_map = {}
@map = {}

@marks = {}
@mtn_map = {}

File.open('marks-mtn.txt').each do |l|
  mark, id = l.split
  @marks[mark] = id
end

File.open('marks-git.txt').each do |l|
  mark, git_id = l.split
  mtn_id = @marks[mark]
  @mtn_map[mtn_id] = git_id
end

File.open('svn_authors_map.txt').each do |l|
  l.scan(/(.*) = (.*) <(.*)>/) do |id,name,email|
    @map[id] = [name, email]
  end
end

# get svn-rev -> git-sha1 mapping
File.open('svn-revisions').each do |l|
  svn_id, mtn_id = l.split
  git_id = @mtn_map[mtn_id]
  @svn_map[svn_id] ||= []
  @svn_map[svn_id] << git_id
end

# convert svn path authors to something useful
File.open('svn_authors.txt').each do |l|
  rev, author = l.chomp.split(' ', 2)
  mark = author[0] == '#'[0]
  if not mark
    author.gsub!(/ ?\(.*/,'')
  else
    author = author[2..-1]
  end
  if author =~ /^(.*) <(.*)>/
    name, email = $1, $2
  elsif mark and @map[author]
    name, email = @map[author]
  else
    name, email = author, 'unknown'
  end
  @svn_map[rev].each do |id|
    @commit_authors.puts([id, name, email].join(':'))
  end
end

def fix_commit(rev, author = '')
  id = @mtn_map[rev]
  author.scan(/(.*) <(.*)>/) do |name, email|
    @commit_authors.puts([id, name, email].join(':'))
  end

  return if not block_given?

  File.open("#{@messages}/#{id}", 'w') do |f|
    f.puts(yield)
  end
end

require './fix_commits'

@commit_authors.fsync

FileUtils.rm_rf('pidgin-fix.git')
system 'git clone --bare pidgin.git pidgin-fix.git'

ENV['GIT_DIR'] = 'pidgin-fix.git'

# check for lingering heads

@branches = {}

run_query %{select b.branch,lower(hex(b.revision_id)) from branch_leaves b} do |branch, id|
  @branches[branch] ||= []
  @branches[branch] << id
end

@branches.select { |branch, ids| ids.count > 1 }.each do |branch,ids|
  count = 0
  ids.each do |id|
    git_id = @mtn_map[id]
    bad = `git branch --contains #{git_id} | wc -l`.chomp.to_i == 0
    system "git branch tmp-#{branch}-#{count += 1} #{git_id}" if bad
  end
end

env_filter = <<EOF
line=$(grep "^$GIT_COMMIT:" "#{@fwd}/commit_authors")
if [ "$line" ]; then
  IFS=':' read __ GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL <<< "$line"
  export GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL
fi
EOF

msg_filter = <<EOF
if [ -f "#{@messages}/$GIT_COMMIT" ]; then
  cat "#{@messages}/$GIT_COMMIT"
else
  cat -
fi
EOF

system "git filter-branch -d /tmp/git-rewrite/ --env-filter '#{env_filter}' --msg-filter '#{msg_filter}' --tag-name-filter cat -- --all"

# cleanup old stuff
system 'git remote rm origin'
system 'rm -rf pidgin-fix.git/refs/original'
system 'git reflog expire --expire=now --all'
system 'git prune --expire=now'
